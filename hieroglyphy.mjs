const EMPTY_LIST = "[]"
const EMPTY_OBJ = "{}"

const NOT = val => `!${val}`
const toNum = val => `+${val}`
const toEnclosedNum = val => `+(${val})`

// Use type coercion to transform basic entities into primitive values false, 0 and Nan
const _FALSE = NOT(EMPTY_LIST)    // ![] -> false
const _ZERO = toNum(EMPTY_LIST)   // +[] -> 0
const _NaN = toNum(EMPTY_OBJ)     // +{} -> NaN (but you knew that of course...)

// From false, derive true and 1
const _TRUE = NOT(_FALSE)         // !![]  -> true
const _ONE = toNum(_TRUE)         // +!![] -> 1

// By concatenating an empty list, we get the sting representation of the primitive values
const toStr = val => `${val}${_ZERO}`
const str_true = toStr(_TRUE)
const str_false = toStr(_FALSE)
const str_NaN = toStr(_NaN)
const str_undefined = toStr(`${EMPTY_LIST}[${_ZERO}]`)
const str_object_Object = `${EMPTY_LIST}${_NaN}`

// Extract a character at a particular index within a string
const charInString = str => idx => `(${str})[${idx}]`
const encodeFromObj = charInString(str_object_Object)
const encodeFromNaN = charInString(str_NaN)
const encodeFromUndefined = charInString(str_undefined)
const encodeFromTrue = charInString(str_true)
const encodeFromFalse = charInString(str_false)

// Starting with [_ZERO, _ONE], the numbers 2 to 9 can be generated by concatenating _TRUE with n+1 copies of _ONE
const numbers = [...new Array(8)]
  .reduce((acc, _, n) => (_ => acc)(acc.push(`${_TRUE + _ONE.repeat(n + 1)}`)), [_ZERO, _ONE])

// Start filling the character encoding cache with values whose definitions can be derived by extracting various
// letters from reserved words
// This cache must be built up progressively as later entries often depend upon the definition of earlier entries
export const charCache = {
  "0": `(${toStr(numbers[0])})`,
  "1": `(${toStr(numbers[1])})`,
  "2": `(${toStr(numbers[2])})`,
  "3": `(${toStr(numbers[3])})`,
  "4": `(${toStr(numbers[4])})`,
  "5": `(${toStr(numbers[5])})`,
  "6": `(${toStr(numbers[6])})`,
  "7": `(${toStr(numbers[7])})`,
  "8": `(${toStr(numbers[8])})`,
  "9": `(${toStr(numbers[9])})`,

  " ": encodeFromObj(numbers[7]),
  "[": encodeFromObj(numbers[0]),

  "a": encodeFromNaN(numbers[1]),
  "b": encodeFromObj(numbers[2]),
  "c": encodeFromObj(numbers[5]),
  "d": encodeFromUndefined(numbers[2]),
  "e": encodeFromTrue(numbers[3]),
  "f": encodeFromFalse(numbers[0]),
  "i": encodeFromUndefined(numbers[5]),
  "j": encodeFromObj(numbers[3]),
  "l": encodeFromFalse(numbers[2]),
  "N": encodeFromNaN(numbers[0]),
  "n": encodeFromUndefined(numbers[1]),
  "O": encodeFromObj(numbers[8]),
  "o": encodeFromObj(numbers[1]),
  "r": encodeFromTrue(numbers[1]),
  "s": encodeFromFalse(numbers[3]),
  "t": encodeFromTrue(numbers[0]),
  "u": encodeFromUndefined(numbers[0]),
}

// Generate a concatenated string of encoded characters from the supplied list of indices
const concatChars = (...idxs) => idxs.map(idx => charCache[idx]).join("+")

charCache["]"] = encodeFromObj(concatChars(1, 4))

// The argument to charInString() evals to 'function String() { [native code] }' from which we can extract 'S' and 'g'
const encConstructor = concatChars('c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r')
const encodeFromStr = charInString(`${EMPTY_LIST}+${encodeFromObj(encConstructor)}`)

charCache["S"] = encodeFromStr(numbers[9])
charCache["g"] = encodeFromStr(toEnclosedNum(concatChars(1, 4)))

const encodeFrom1e100 = charInString(toStr(`+(${numbers[1]}+${concatChars('e', 1, 0, 0)})`))
charCache["+"] = encodeFrom1e100(numbers[2])

const encodeFromInfinity = charInString(toStr(`+(${numbers[1]}+${concatChars('e', 1, 0, 0, 0)})`))
charCache["I"] = encodeFromInfinity(numbers[0])
charCache["y"] = encodeFromInfinity(numbers[7])

// Use Number.prototype.toString(<number base>) to generate the remaining lowercase letters of the alphabet.
// The number must be specified as the sum of digits <= 9
const encToString = concatChars('t', 'o', 'S', 't', 'r', 'i', 'n', 'g')
const base36 = toEnclosedNum(concatChars(3, 6))
charCache["h"] = `(${toEnclosedNum(concatChars(1, 7))})[${encToString}](${base36})`
charCache["k"] = `(${toEnclosedNum(concatChars(2, 0))})[${encToString}](${base36})`
charCache["m"] = `(${toEnclosedNum(concatChars(2, 2))})[${encToString}](${base36})`
charCache["p"] = `(${toEnclosedNum(concatChars(2, 5))})[${encToString}](${base36})`
charCache["q"] = `(${toEnclosedNum(concatChars(2, 6))})[${encToString}](${base36})`
charCache["v"] = `(${toEnclosedNum(concatChars(3, 1))})[${encToString}](${base36})`
charCache["w"] = `(${toEnclosedNum(concatChars(3, 2))})[${encToString}](${base36})`
charCache["x"] = `(${toEnclosedNum(concatChars(3, 3))})[${encToString}](${base36})`
charCache["y"] = `(${toEnclosedNum(concatChars(3, 4))})[${encToString}](${base36})`
charCache["z"] = `(${toEnclosedNum(concatChars(3, 5))})[${encToString}](${base36})`

// Build the function constructor function so we can call the native escape and unescape functions
// []["sort"]["constructor"] -> [Function: Function]
const functionConstructor = `${EMPTY_LIST}[${concatChars('s', 'o', 'r', 't')}][${encConstructor}]`
export const encodeScript = src => `${functionConstructor}(${encodeString(src)})()`

const unescape = encodeScript("return unescape")

// escape('[') -> '%5B' from which we can extract the percent character
charCache["%"] = `${encodeScript("return escape")}${charInString(charCache["["])(numbers[0])}`

const encodeChar = char =>
  (charCode =>
    // For 7-bit ASCII, use the unescaped sequence as this will always be shorter than the unicode sequence
    charCode < 128
      ? `${unescape}(${encodeString(`%${charCode.toString(16).padStart(2, "0")}`)})`
      : encodeString(`\\u${charCode.toString(16).padStart(4, "0")}`)
  )(char.charCodeAt(0))

// This function contains circular references and is forward-referenced from earlier coding; therefore, it cannot be
// transformed into an arrow function as the JavaScript compiler does not hoist arrow functions - and hoisting is the
// language feature that allows us to get away with both forward references and circularity.
export function encodeString(str) {
  return [...str]
    .map(c => { if (!charCache[c]) charCache[c] = encodeChar(c); return charCache[c] })
    .join("+")
}

export const encodeNumber = maybeNum => (n => n <= 9 ? numbers[n] : `+(${encodeString(n.toString(10))})`)(+maybeNum)
