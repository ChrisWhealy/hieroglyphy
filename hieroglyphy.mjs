export const EMPTY_LIST = "[]"
export const EMPTY_OBJ = "{}"

export const NOT = val => `!${val}`
export const toNum = val => `+${val}`

// Start by using JavaScript type coercion to generate the encoded representation of primitive values
export const _FALSE = NOT(EMPTY_LIST)    // An empty list coerced to a Boolean is false
export const _TRUE = NOT(_FALSE)         // True is NOT false (duh...)
export const _ZERO = toNum(EMPTY_LIST)   // Zero is an empty list coerced to a number
export const _ONE = toNum(_TRUE)         // One is true coerced to a number
export const _NaN = toNum(EMPTY_OBJ)     // NaN is an empty object coerced to a number (of course...)

// Next, generate the string encoding of the primitive types
export const toStr = val => `${val}${_ZERO}`
export const str_true = toStr(_TRUE)
export const str_false = toStr(_FALSE)
export const str_NaN = toStr(_NaN)
export const str_undefined = toStr(`${EMPTY_LIST}[${_ZERO}]`)
export const str_object_Object = `${EMPTY_LIST}${_NaN}`

// Extract individual ASCII characters at a particular index within a string
export const charInString = str => idx => `(${str})[${idx}]`
export const encodeFromObj = charInString(str_object_Object)
export const encodeFromNaN = charInString(str_NaN)
export const encodeFromUndefined = charInString(str_undefined)
export const encodeFromTrue = charInString(str_true)
export const encodeFromFalse = charInString(str_false)

// Starting with [_ZERO, _ONE], the numbers 2 to 9 can be generated by concatenating _TRUE with n+1 copies of _ONE
export const numbers = [...new Array(8)]
  .reduce((acc, _, n) => (_ => acc)(acc.push(`${_TRUE + _ONE.repeat(n + 1)}`)), [_ZERO, _ONE])

// Start filling the character encoding cache with values whose definitions can be derived from reserved words
// This cache must be built up progressively as later entries often depend upon the definition of earlier entries
export const charCache = {
  "0": `(${toStr(numbers[0])})`,
  "1": `(${toStr(numbers[1])})`,
  "2": `(${toStr(numbers[2])})`,
  "3": `(${toStr(numbers[3])})`,
  "4": `(${toStr(numbers[4])})`,
  "5": `(${toStr(numbers[5])})`,
  "6": `(${toStr(numbers[6])})`,
  "7": `(${toStr(numbers[7])})`,
  "8": `(${toStr(numbers[8])})`,
  "9": `(${toStr(numbers[9])})`,

  " ": encodeFromObj(numbers[7]),
  "[": encodeFromObj(numbers[0]),
  "a": encodeFromNaN(numbers[1]),
  "b": encodeFromObj(numbers[2]),
  "c": encodeFromObj(numbers[5]),
  "d": encodeFromUndefined(numbers[2]),
  "e": encodeFromTrue(numbers[3]),
  "f": encodeFromFalse(numbers[0]),
  "i": encodeFromUndefined(numbers[5]),
  "j": encodeFromObj(numbers[3]),
  "l": encodeFromFalse(numbers[2]),
  "N": encodeFromNaN(numbers[0]),
  "n": encodeFromUndefined(numbers[1]),
  "O": encodeFromObj(numbers[8]),
  "o": encodeFromObj(numbers[1]),
  "r": encodeFromTrue(numbers[1]),
  "s": encodeFromFalse(numbers[3]),
  "t": encodeFromTrue(numbers[0]),
  "u": encodeFromUndefined(numbers[0]),
}

// Generate a string of number primitives or characters concatenated from the supplied list of indices
export const concatNums = (...idxs) => idxs.map(idx => `(${numbers[idx]})`).join("+")
export const concatChars = (...idxs) => idxs.map(idx => charCache[idx]).join("+")

charCache["]"] = encodeFromObj(concatChars(1, 4))

export const enc_constructor = concatChars('c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r')
export const encodeFromStr = charInString(`${EMPTY_LIST}+${encodeFromObj(enc_constructor)}`)

charCache["S"] = encodeFromStr(numbers[9])
charCache["g"] = encodeFromStr(concatNums(7, 7))

export const encodeFrom1e100 = charInString(toStr(`+(${numbers[1]}+${concatChars('e', 1, 0, 0)})`))
charCache["+"] = encodeFrom1e100(numbers[2])

export const encodeFromInfinity = charInString(toStr(`+(${numbers[1]}+${concatChars('e', 1, 0, 0, 0)})`))
charCache["I"] = encodeFromInfinity(numbers[0])
charCache["y"] = encodeFromInfinity(numbers[7])

export const enc_toString = concatChars('t', 'o', 'S', 't', 'r', 'i', 'n', 'g')
charCache["h"] = `(${concatNums(9, 8)})[${enc_toString}](${concatNums(9, 9)})`
charCache["p"] = `(${concatNums(9, 9, 7)})[${enc_toString}](${concatNums(9, 9, 8)})`

export const functionConstructor = `${EMPTY_LIST}[${concatChars('s', 'o', 'r', 't')}][${enc_constructor}]`
export const encodeScript = src => `${functionConstructor}(${encodeString(src)})()`

export const unescape = encodeScript("return unescape")
export const escape = encodeScript("return escape")

charCache["%"] = `${escape}${charInString(charCache["["])(numbers[0])}`

export const encodeChar = char =>
  (charCode =>
    // For 7-bit ASCII, use the unescaped sequence as this will always be shorter than the unicode sequence
    charCode < 128
      ? `${unescape}(${encodeString(`%${charCode.toString(16).padStart(2, "0")}`)})`
      : encodeString(`\\u${charCode.toString(16).padStart(4, "0")}`)
  )(char.charCodeAt(0))

// This function contains circular references and is forward-referenced from earlier coding; therefore, it cannot be
// transformed into an arrow function as the JavaScript compiler does not hoist arrow functions - and hoisting is the
// language feature that allows us to get away with both forward references and circularity.
export function encodeString(str) {
  return [...str].map(c => { if (!charCache[c]) charCache[c] = encodeChar(c); return charCache[c] }).join("+")
}

export const encodeNumber = n => (n => n <= 9 ? numbers[n] : `+(${encodeString(n.toString(10))})`)(+n)
