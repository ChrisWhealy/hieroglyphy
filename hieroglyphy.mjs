const EMPTY_LIST = "[]"
const EMPTY_OBJ = "{}"

const NOT = val => `!${val}`
const toNum = val => `+${val}`

// Start by using JavaScript type coercion to generate the encoded representation of primitive values
const _ZERO = toNum(EMPTY_LIST)   // Zero is an empty list coerced to a number
const _FALSE = NOT(EMPTY_LIST)    // False is the NOT of an empty list
const _NaN = toNum(EMPTY_OBJ)     // NaN is an empty object coerced to a number (of course...)
const _TRUE = NOT(_FALSE)         // True is NOT false (duh...)
const _ONE = toNum(_TRUE)         // One is true coerced to a number

// Next, generate the string encoding of the primitive types
const toStr = val => `${val}${_ZERO}`
const str_true = toStr(_TRUE)
const str_false = toStr(_FALSE)
const str_NaN = toStr(_NaN)
const str_undefined = toStr(`${EMPTY_LIST}[${EMPTY_LIST}]`)
const str_object_Object = `${EMPTY_LIST}${_NaN}`

// ASCII characters can be encoded by combining a type prefix with an arbitrary number
const encodeWithPrefix = typePrefix => numSuffix => `(${typePrefix})[${numSuffix}]`
const encodeFromObj = encodeWithPrefix(str_object_Object)
const encodeFromNaN = encodeWithPrefix(str_NaN)
const encodeFromUndefined = encodeWithPrefix(str_undefined)
const encodeFromTrue = encodeWithPrefix(str_true)
const encodeFromFalse = encodeWithPrefix(str_false)

// Starting with [_ZERO, _ONE], the numbers 2 to 9 can be generated by concatenating _TRUE with n+1 copies of _ONE
const numbers = [...new Array(8)]
  .reduce((acc, _, n) => (_ => acc)(acc.push(`${_TRUE + _ONE.repeat(n + 1)}`)), [_ZERO, _ONE])

// Start filling the character encoding cache with values whose definitions become progressively weirder as we go on...
// This cache must be built up progressively as later entries often depend upon the definition of earlier entries
const charCache = {
  "0": `(${toStr(numbers[0])})`,
  "1": `(${toStr(numbers[1])})`,
  "2": `(${toStr(numbers[2])})`,
  "3": `(${toStr(numbers[3])})`,
  "4": `(${toStr(numbers[4])})`,
  "5": `(${toStr(numbers[5])})`,
  "6": `(${toStr(numbers[6])})`,
  "7": `(${toStr(numbers[7])})`,
  "8": `(${toStr(numbers[8])})`,
  "9": `(${toStr(numbers[9])})`,
  " ": encodeFromObj(numbers[7]),
  "[": encodeFromObj(numbers[0]),
  "b": encodeFromObj(numbers[2]),
  "c": encodeFromObj(numbers[5]),
  "j": encodeFromObj(numbers[3]),
  "o": encodeFromObj(numbers[1]),
  "O": encodeFromObj(numbers[8]),
  "a": encodeFromNaN(numbers[1]),
  "N": encodeFromNaN(numbers[0]),
  "d": encodeFromUndefined(numbers[2]),
  "e": encodeFromUndefined(numbers[3]),
  "i": encodeFromUndefined(numbers[5]),
  "n": encodeFromUndefined(numbers[1]),
  "u": encodeFromUndefined(numbers[0]),
  "f": encodeFromFalse(numbers[0]),
  "l": encodeFromFalse(numbers[2]),
  "s": encodeFromFalse(numbers[3]),
  "r": encodeFromTrue(numbers[1]),
  "t": encodeFromTrue(numbers[0]),
}

// Generate a string of number primitives or characters concatenated from the supplied list of indices
const concatNums = (...idxs) => idxs.map(idx => `(${numbers[idx]})`).join("+")
const concatChars = (...idxs) => idxs.map(idx => charCache[idx]).join("+")

charCache["]"] = encodeFromObj(concatChars(1, 4))

const enc_constructor = hieroglyphyString("constructor")
const encodeFromString = encodeWithPrefix(`${EMPTY_LIST}+${encodeFromObj(enc_constructor)}`)

charCache["S"] = encodeFromString(numbers[9])
charCache["g"] = encodeFromString(concatNums(7, 7))

const encodeFrom1e100 = encodeWithPrefix(toStr(`+(${numbers[1]}+${concatChars("e", 1, 0, 0)})`))
charCache["+"] = encodeFrom1e100(numbers[2])

const encodeFromInfinity = encodeWithPrefix(toStr(`+(${numbers[1]}+${concatChars("e", 1, 0, 0, 0)})`))
charCache["y"] = encodeFromInfinity(numbers[7])
charCache["I"] = encodeFromInfinity(numbers[0])

const enc_toString = hieroglyphyString("toString")
charCache["h"] = `(${concatNums(9, 8)})[${enc_toString}](${concatNums(9, 9)})`
charCache["p"] = `(${concatNums(9, 9, 7)})[${enc_toString}](${concatNums(9, 9, 8)})`

const functionConstructor = `${EMPTY_LIST}[${hieroglyphyString("sort")}][${enc_constructor}]`
export const hieroglyphyScript = src => `${functionConstructor}(${hieroglyphyString(src)})()`

const unescape = hieroglyphyScript("return unescape")
const escape = hieroglyphyScript("return escape")

charCache["%"] = `${escape}${encodeWithPrefix(charCache["["])(numbers[0])}`

const encodeChar = char =>
  (charCode =>
    // For 7-bit ASCII, use the unescaped sequence as this will always be shorter than the unicode sequence
    charCode < 128
      ? `${unescape}(${hieroglyphyString(`%${charCode.toString(16).padStart(2, "0")}`)})`
      : hieroglyphyString(`\\u${charCode.toString(16).padStart(4, "0")}`)
  )(char.charCodeAt(0))

// This function contains circular references and is forward-referenced from earlier coding; therefore, it cannot be
// transformed into an arrow function as the JavaScript compiler does not hoist arrow functions - and hoisting is the
// language feature that allows us to get away with both forward references and circularity.
export function hieroglyphyString(str) {
  return [...str].map(c => { if (!charCache[c]) charCache[c] = encodeChar(c); return charCache[c] }).join("+")
}

export const hieroglyphyNumber = n => (n => n <= 9 ? numbers[n] : `+(${hieroglyphyString(n.toString(10))})`)(+n)
